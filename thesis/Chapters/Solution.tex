\chapter{Design of the Solution}
\label{ch:design}

Letâ€™s imagine a global infrastructure with many edge locations. Some web infrastructure companies already provide a network with many locations, like the one of Cloudflare with more than 250 locations worldwide located in more than 100 different countries \cite{cloudflare-network}, or the network of Amazon Web Services (AWS) with more than 265 edge locations \cite{aws-network}.
These networks are only the beginning of the development of edge networks: AWS is currently introducing AWS Wavelength \cite{aws-wavelength} a new service in partnership with popular telecommunication providers (i.e., Verizon, Vodafone) to scale across global 5G networks.


\section{Managing the network}
By having such a vast and heterogeneous network the first step in our approach is to abstract away the difficult management of the deployment to the many edge locations.
In a traditional cloud setup the developer specifies individually on which data center to deploy, this cannot be done efficiently for a vast edge network because the developer would have to specify hundreds of specific deployments.
The developer could also want to use only more powerful data centers and not the limited cloudlets at the border of the network.

\begin{wrapfigure}[11]{r}{5.5cm} % [11] is how many lines should be wrapped
\caption{An example of the hierarchy.}
\label{fig:hierarchy}
\includegraphics[width=5.5cm]{Figures/Solution/hierarchy.png}
\end{wrapfigure} 

To allow flexibility in the deployments and, as we will see later, to allow geographical aggregations we can organize the various machines running in the data centers and cloudlets in a hierarchy with multiple levels.
In Figure \ref{fig:hierarchy} we reported an example: we first have a division by continent (or large regions), then by country, territory, city and district.
Note that each element in the hierarchy should not necessarily be a different data center: a big data center in Milan can be both a receiver for "city" and "country" deployments/aggregations.
\vspace{0.5cm}


\subsection{Specifying locations}
The job of specifying the available locations should be responsibility of the web infrastructure company, but still the developer may want to customize the arrangement or may want to use their personal infrastructure. 

So we must provide a way to specify the hierarchy, we chose to implement the API in the following way:
\begin{itemize}
    \item Levels: the list of levels characterized by their identifiers (e.g., "continent", "country", "territory", "city", "district");
    \item Hierarchy: a way to specify the hierarchy, starting from the uppermost level and going down to the lowest level. Each level can contain multiple locations, and each location will aggregate data of the relative area;
    \item Location: each location must be associated to an entry point that defines the actual cloudlet or data center to be used (so for the location there must be defined gateway, port and password).
\end{itemize}

TODO show constraints


\subsection{Specifying deployments}
Now that we have the hierarchy specified we can use this hierarchy to make a powerful deployment API. The developer should be able to deploy on a specific level of the hierarchy only in a certain area and to exclude a specific subsection from this area.

To allow such deployment we established the following concepts:
\begin{itemize}
    \item \inlinecode{inEvery}: a string representing the level on which to deploy the function.
    \item \inlinecode{inAreas}: a list of string of areas, specifying in which areas to deploy. If unspecified we can assume the developer wants it deployed everywhere. 
     \item \inlinecode{exceptIn}: a list of string of areas, that are an exception to what previously defined before. In the locations contained in these areas the developer does not want to perform the deployment.
\end{itemize}

\begin{example}
Deploy on every city in Europe and Asia, excluding the cities in Italy and excluding the city of Tokyo.
Becomes:
\begin{itemize}
    \item \inlinecode{inEvery}: "city"
    \item \inlinecode{inAreas}: ["europe", "asia"]
     \item \inlinecode{exceptIn}: ["italy", "tokyo"]
\end{itemize}
\end{example}

\begin{example}
Deploy on every district in Europe and India, excluding the districts in France and excluding the districts in Milan.
Becomes:
\begin{itemize}
    \item \inlinecode{inEvery}: "district"
    \item \inlinecode{inAreas}: ["europe", "india"]
     \item \inlinecode{exceptIn}: ["france", "milan"]
\end{itemize}
\end{example}

In the examples we saw that the developer should also be allowed to mix the levels of the areas specified, using different levels of the hierarchy inside the \inlinecode{inAreas} and \inlinecode{exceptIn} lists.

TODO show constraints


\section{Managing limited resources}
Usually edge locations have limited resources compared to central data centers, so web infrastructure companies have to work around the limitations in order to provide a reliable service.
Due to these limitations, Function-as-a-Service (FaaS) is the current de facto standard for companies that provide computing resources at the edge to the public. Examples of services are AWS Lambda@Edge (an evolution of the famous AWS Lambda service on the cloud) \cite{aws-lambda-at-edge} or Cloudflare Workers \cite{cloudflare-workers}. It can be easily understood that providing Infrastructure-as-a-Service (IaaS) or Platform-as-a-Service (PaaS) to the public on the limited resources available at the edge is clearly less efficient for companies.

Therefore we decided to use in our framework the FaaS paradigm as a way to allow the users of the framework (the developers) to perform computation on the edge. The developer, should also be able to specify the RAM memory allocated for the function. The default allocated memory can be a low value, but if there is a more complex function requiring additional memory usage the developer can change the allocated memory (the web infrastructure company can then charge more based on the memory requested).

But resources are not only limited in the sense of computation, but also the storage resources are limited on the edge. To take into account the aforementioned issue we decided to use a key-value database for the stateful part of our approach. A key-value database allows us to perform extremely efficient (but simple) queries, and is perfect for the limited resources available on the edge. To avoid to accumulate data we also introduced in our framework a Time-To-Live (TTL) which the developer must specify. For example with a TTL of 5 days, after making a write to the database the data, if not updated, can be deleted after 5 days.


\subsection{Writing data}
Our goal is to provide the developers an easy way to create geographical aggregations of data. If for the data it does not make sense to create geographical aggregations then it would make more sense to use a core-centric approach to manage this data. In our approach by having the data geographically distributed it means that those data correspond to information coming from the respective geographic area.

Furthermore in Chapter \ref{ch:problem_formulation} we outlined use cases which are static in the sense of location, or for which having discontinuity in the data is not a problem. Therefore we decided to not introduce any session consistency to avoid the cost of managing such sessions: heavy communications between the locations. This means that if we are performing a "city" aggregation and a client that is sending data is currently travelling and changes its position to a new "city" area, then its old data will remain the in the previous "city" area and not transferred to the new one.

To manage such conditions our approach should have the following properties:
\begin{itemize}
    \item Write Action: the action to perform for writing data (e.g., set, add to list, ...)
    \item Key: The key that will be associated to the value as in a standard key-value database.
     \item Data: the data to be associated to the key (so it can be then obtained from the key) or the data to be added to the list specified by the key.
     \item Referring Area Level: the higher level on which to aggregate the data.
     \item Should Save In Intermediate Levels: a true or false property that if set to true saves the data only in the level specified by the Referring Area Level, otherwise the data is saved on the receiving level and on all the other upper levels, up until the level specified by Referring Area Level.
     \item Time To Live: limits the lifespan of the data.
\end{itemize}

To provide some examples, in the code that will be deployed on the "city" level the developer can make the following write calls:

\begin{example}
\begin{itemize}
    \item Write Action: set
    \item Key: mykey1
    \item Data: data1
    \item Referring Area Level: continent
    \item Should Save In Intermediate Levels: false
    \item Time To Live: 10 days
\end{itemize}
The framework will save the data only at the continent level (so if the code is executed in the "milan" location, the data will be saved in the "europe" location). The framework will create (or update) key "mykey1" with the value "data1" and will set a lifespan of the data to 10 days.
\end{example}

\begin{example}
\begin{itemize}
    \item Write Action: set
    \item Key: mykey2
    \item Data: data2
    \item Referring Area Level: continent
    \item Should Save In Intermediate Levels: true
    \item Time To Live: 30 days
\end{itemize}
The framework will save the data at the continent, country, territory and city levels (so if the code is executed in the "milan" location, the data will be saved in the "it-north", "italy" and "europe" locations). In each of these locations the framework will create (or update) key "mykey2" with the value "data2" and will set a lifespan of the data to 30 days.
\end{example}

\begin{example}
\begin{itemize}
    \item Write Action: add to list
    \item Key: mylist1
    \item Data: data1
    \item Referring Area Level: continent
    \item Should Save In Intermediate Levels: false
    \item Time To Live: 1 day
\end{itemize}
The framework will save the data only at the continent level (so if the code is executed in the "milan" location, the data will be saved in the "europe" location). The framework will add to the list associated to the key "mylist1" the value "data1" and will set a lifespan to the single element of the list 1 day.
\end{example}


\subsection{Reading data}
As we have seen the developer has to think carefully how to handle the writing of the data with the objective to partition geographically the data. But after data have been thoughtfully partitioned then the reading of the data is instantaneous.
When running the code in a certain location, by specifying only the reading action and key the framework obtains the data present in the location and associated to that key.

So only the following two properties are use for making reads:
\begin{itemize}
    \item Read Action: the action to perform for reading data, "get" to obtain the single value from the key (saved with "set"), "get list" to obtain all the values saved with "add to list".
    \item Key: The key of the value or the list to be read.
\end{itemize}

To provide some examples, in the code that will be deployed on the "continent" level, for reading the data saved in that "continent" location (e.g., "europe" location) the developer can make the following read calls:
\begin{example}
\begin{itemize}
    \item Read Action: get
    \item Key: mykey1
\end{itemize}
The framework will obtain the value associated to the key "mykey1" if present and if not expired due to the TTL.
\end{example}

\begin{example}
\begin{itemize}
    \item Read Action: get list
    \item Key: mylist1
\end{itemize}
The framework will obtain all the not expired elements contained in the list associated to the key "mylist1".
\end{example}


\section{Applying to use cases}
TODO show how these APIs can be used in a few use cases











\iffalse
``This approach is similar to the one proposed in a recent work by Nuara et al.~\cite{nuara2020driving}, in which ..."
\fi
